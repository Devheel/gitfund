// Public Domain (-) 2016 The GitFund Authors.
// See the GitFund UNLICENSE file for details.

package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"reflect"
	"sort"
	"strings"
	"text/template"
	"time"
	"unicode"
	"unicode/utf8"

	"github.com/tav/gitfund/app/model"
)

var (
	typeOfByteSlice = reflect.TypeOf([]byte(nil))
	typeOfTime      = reflect.TypeOf(time.Time{})
)

type Definitions []*Method

func (d Definitions) Len() int {
	return len(d)
}

func (d Definitions) Less(i, j int) bool {
	if d[i].ReceiverType == d[j].ReceiverType {
		return d[i].Name < d[j].Name
	}
	return d[i].ReceiverType < d[j].ReceiverType
}

func (d Definitions) Swap(i, j int) {
	d[i], d[j] = d[j], d[i]
}

func (d Definitions) Write(buf *bytes.Buffer) {
	sort.Sort(d)
	for _, meth := range d {
		if meth.ReceiverType == "" {
			fmt.Fprintf(buf, "\nfunc %s%s {\n%s\n}\n",
				meth.Name, meth.Signature, strings.TrimSuffix(meth.Body, "\n"))
		} else {
			fmt.Fprintf(buf, "\nfunc (%s *%s) %s%s {\n%s\n}\n",
				meth.ReceiverID, meth.ReceiverType, meth.Name, meth.Signature,
				strings.TrimSuffix(meth.Body, "\n"))
		}
	}
}

type Method struct {
	Body         string
	Name         string
	ReceiverID   string
	ReceiverType string
	Signature    string
}

type Prop struct {
	auto     string
	field    string
	multiple bool
	name     string
	noindex  bool
	typ      string
}

type Schema struct {
	dbfields map[string]*Prop
	fields   map[string]*Prop
	kind     string
	props    []*Prop
	slices   []string
}

type TemplateData struct {
	Field     string
	FieldName string
	Initial   string
	NoIndex   bool
	Kind      string
	KindLower string
	Type      string
}

func exit(format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, "ERROR: "+format+"\n", args...)
	os.Exit(1)
}

func render(name string, text string, data interface{}) string {
	tmpl := template.Must(template.New(name).Parse(strings.TrimPrefix(text, "\n")))
	buf := &bytes.Buffer{}
	err := tmpl.Execute(buf, data)
	if err != nil {
		exit("could not render %s method: %s", err)
	}
	return buf.String()
}

func main() {

	if len(os.Args) != 3 {
		fmt.Println("Usage: genmodel MODEL_PACKAGE_FILE WEB_PACKAGE_FILE")
		os.Exit(1)
	}

	// Sort the entity kinds into alphabetical order.
	keys := []string{}
	for key, _ := range model.KindRegistry {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	// Define a map to hold the schema definitions.
	schemas := map[string]*Schema{}

	// Create the buffers to write to.
	fbuf := &bytes.Buffer{}
	sbuf := &bytes.Buffer{}

	// Spit out the header for the model package file with the opening for the
	// const block.
	fbuf.WriteString(`// AUTOGENERATED. DO NOT EDIT.

package model

import (
	"fmt"
	"time"

	"github.com/tav/gitfund/app/config"
	"google.golang.org/cloud/datastore"
)

const (
`)

	// Spit out the header for the web package file with a dummy variable using
	// the time package in case time.Time isn't used anywhere.
	sbuf.WriteString(`// AUTOGENERATED. DO NOT EDIT.

package web

import (
	"time"

	"github.com/tav/gitfund/app/model"
)

var _ = time.Time{}
`)

	// Loop over each entity kind, validate, and write the relevant metadata.
	for _, key := range keys {
		rt := reflect.TypeOf(model.KindRegistry[key])
		kind := rt.Name()
		fmt.Fprintf(fbuf, "\t%sKind = %q\n", kind, key)
		n := rt.NumField()
		seen := map[string]string{}
		dbfields := map[string]*Prop{}
		fields := map[string]*Prop{}
		props := []*Prop{}
		slices := []string{}
		for i := 0; i < n; i++ {
			field := rt.Field(i)
			// Skip unexported fields.
			r, _ := utf8.DecodeRuneInString(field.Name)
			if !unicode.IsUpper(r) {
				continue
			}
			// Ensure the field has a datastore struct tag.
			tag := field.Tag.Get("model")
			if tag == "" {
				exit("missing model struct tag for %s.%s", kind, field.Name)
			}
			// Ensure the field name hasn't been used already.
			split := strings.Split(tag, ",")
			name := ""
			noindex := false
			auto := ""
			switch len(split) {
			case 3:
				name = split[0]
				if split[1] == "noindex" {
					noindex = true
					auto = split[2]
				} else if split[2] == "noindex" {
					noindex = true
					auto = split[1]
				} else {
					exit("invalid struct tag for %s.%s: %q", kind, field.Name, tag)
				}
			case 2:
				name = split[0]
				if split[1] == "noindex" {
					noindex = true
				} else {
					auto = split[1]
				}
			case 1:
				name = split[0]
			default:
				exit("invalid struct tag for %s.%s: %q", kind, field.Name, tag)
			}
			name = strings.TrimSpace(name)
			if name == "" {
				exit("empty datastore field name for %s.%s: %q", kind, field.Name, tag)
			}
			if prev, exists := seen[name]; exists {
				exit("datastore field name %q for %s.%s already used for %s.%s", name, kind, field.Name, kind, prev)
			}
			seen[name] = field.Name
			// Define the property.
			ft := field.Type
			multiple := false
			typ := ""
			switch ft {
			case typeOfByteSlice:
				typ = "[]byte"
			case typeOfTime:
				typ = "time.Time"
			default:
				switch ft.Kind() {
				case reflect.Bool:
					typ = "bool"
				case reflect.Float64:
					typ = "float64"
				case reflect.Int64:
					typ = "int64"
				case reflect.Slice:
					multiple = true
					st := ft.Elem()
					switch ft.Elem() {
					case typeOfByteSlice:
						typ = "[]byte"
					default:
						slices = append(slices, field.Name)
						switch st.Kind() {
						case reflect.Bool:
							typ = "bool"
						case reflect.Float64:
							typ = "float64"
						case reflect.Int64:
							typ = "int64"
						case reflect.String:
							typ = "string"
						default:
							exit("unsuported slice type %s specified for %s.%s", ft, kind, field.Name)
						}
					}
				case reflect.String:
					typ = "string"
				default:
					exit("unsupported type %s specified %s.%s", ft, kind, field.Name)
				}
			}
			if multiple && auto != "" {
				exit("default value %q set for %s field %s.%s", auto, ft, kind, field.Name)
			}
			prop := &Prop{
				auto:     auto,
				field:    field.Name,
				multiple: multiple,
				name:     name,
				noindex:  noindex,
				typ:      typ,
			}
			props = append(props, prop)
			dbfields[name] = prop
			fields[field.Name] = prop
			// If not indexed, skip writing out the field name to the model
			// package file.
			if noindex {
				continue
			}
			fmt.Fprintf(fbuf, "\t%s_%s = \"%s\"\n", kind, field.Name, name)
			fmt.Fprintf(fbuf, "\t%s_%s_desc = \"-%s\"\n", kind, field.Name, name)
			fmt.Fprintf(fbuf, "\t%s_%s_eq = \"%s =\"\n", kind, field.Name, name)
			fmt.Fprintf(fbuf, "\t%s_%s_gt = \"%s >\"\n", kind, field.Name, name)
			fmt.Fprintf(fbuf, "\t%s_%s_gte = \"%s >=\"\n", kind, field.Name, name)
			fmt.Fprintf(fbuf, "\t%s_%s_lt = \"%s <\"\n", kind, field.Name, name)
			fmt.Fprintf(fbuf, "\t%s_%s_lte = \"%s <=\"\n", kind, field.Name, name)
		}
		schemas[key] = &Schema{
			dbfields: dbfields,
			fields:   fields,
			kind:     kind,
			props:    props,
			slices:   slices,
		}
	}

	// Close the const block of the model package file and write a dummy
	// variable using the time package in case time.Time isn't used anywhere.
	fbuf.WriteString(`)

var _ = time.Time{}
`)

	// Initialise method definition lists and temporary buffers.
	fmeths := Definitions{}
	smeths := Definitions{}
	consBuf := &bytes.Buffer{}
	loadBuf := &bytes.Buffer{}
	saveBuf := &bytes.Buffer{}

	// Loop through the schema definitions and write out the various utility
	// methods.
	for _, key := range keys {
		schema := schemas[key]
		initial := strings.ToLower(string(schema.kind[0]))
		// Write the header for the Load method.
		fmt.Fprint(loadBuf, "\tvar (\n\t\tok bool\n")
		if len(schema.slices) > 0 {
			fmt.Fprint(loadBuf, "\t\tslice []interface{}\n")
		}
		fmt.Fprint(loadBuf, "\t)\n")
		// Sort the model fields into alphabetical order.
		fields := []string{}
		for field, _ := range schema.fields {
			fields = append(fields, field)
		}
		sort.Strings(fields)
		// Sort the datastore field names into alphabetical order.
		dbfields := []string{}
		for dbfield, _ := range schema.dbfields {
			dbfields = append(dbfields, dbfield)
		}
		sort.Strings(dbfields)
		// Loop through the fields and write out code to load the property.
		fmt.Fprint(loadBuf, "\tfor _, prop := range props {\n\t\tswitch prop.Name {\n")
		for _, dbfield := range dbfields {
			prop := schema.dbfields[dbfield]
			fmt.Fprintf(loadBuf, "\t\tcase %q:\n", dbfield)
			if prop.multiple {
				fmt.Fprint(loadBuf, render("Load", `
			slice, ok = prop.Value.([]interface{})
			if !ok {
				return fmt.Errorf("model: property for {{.Kind}}.{{.Field}} element does not have an []interface{} value")
			}
			if len(slice) > 0 {
				values := make([]{{.Type}}, len(slice))
				for idx, value := range slice {
					val, ok := value.({{.Type}})
					if !ok {
						return fmt.Errorf("model: property for {{.Kind}}.{{.Field}} element is not a {{.Type}}")
					}
					values[idx] = val
				}
				{{.Initial}}.{{.Field}} = values
			}
`, TemplateData{Field: prop.field, Initial: initial, Kind: schema.kind, Type: prop.typ}))
			} else {
				fmt.Fprintf(loadBuf, "\t\t\t%s.%s, ok = prop.Value.(%s)\n", initial, prop.field, prop.typ)
				fmt.Fprintf(loadBuf,
					"\t\t\tif !ok {\n\t\t\t\treturn fmt.Errorf(`model: property for %s.%s is not a %s`)\n\t\t\t}\n",
					schema.kind, prop.field, prop.typ)
			}
		}
		// Append the footer for the Load method and write out the definition.
		fmt.Fprint(loadBuf, "\t\t}\n\t}\n\treturn nil")
		fmeths = append(fmeths, &Method{
			Body:         loadBuf.String(),
			Name:         "Load",
			ReceiverID:   initial,
			ReceiverType: schema.kind,
			Signature:    "(props []datastore.Property) error",
		})
		loadBuf.Reset()
		// Write the headers for the NewX and Save methods.
		fmt.Fprintf(consBuf, "\treturn &%s{", schema.kind)
		if len(schema.slices) > 0 {
			fmt.Fprint(saveBuf, "\tvar slice []interface{}\n")
		}
		fmt.Fprint(saveBuf, "\tprops := []datastore.Property{}\n")
		// Loop through the fields and write out related code for the NewX and
		// Save methods.
		autoset := false
		for _, field := range fields {
			prop := schema.fields[field]
			if prop.multiple {
				fmt.Fprint(saveBuf, render("Save.field.multiple", `
	slice = make([]interface{}, len({{.Initial}}.{{.Field}}))
	for idx, elem := range {{.Initial}}.{{.Field}} {
		slice[idx] = elem
	}
	props = append(props, datastore.Property{
		Name: "{{.FieldName}}",
		NoIndex: {{.NoIndex}},
		Value: slice,
	})
`, TemplateData{Field: field, FieldName: prop.name, Initial: initial, NoIndex: prop.noindex}))
			} else {
				fmt.Fprint(saveBuf, render("Save.field", `
	props = append(props, datastore.Property{
		Name: "{{.FieldName}}",
		NoIndex: {{.NoIndex}},
		Value: {{.Initial}}.{{.Field}},
	})
`, TemplateData{Field: field, FieldName: prop.name, Initial: initial, NoIndex: prop.noindex}))
			}
			if prop.auto != "" {
				switch prop.typ {
				case "string":
					autoset = true
					fmt.Fprintf(consBuf, "\n\t\t%s: %q,", field, prop.auto)
				case "int64", "float64", "bool":
					autoset = true
					fmt.Fprintf(consBuf, "\n\t\t%s: %s,", field, prop.auto)
				case "[]byte":
					autoset = true
					fmt.Fprintf(consBuf, "\n\t\t%s: []byte(%q),", field, prop.auto)
				case "time.Time":
					if prop.auto == "now" {
						autoset = true
						fmt.Fprintf(consBuf, "\n\t\t%s: time.Now().UTC(),", field)
					} else {
						exit("unsupported default value %q for time.Time field %s.%s",
							prop.auto, schema.kind, field)
					}
				}
			}
		}
		// Append the footer for the Save method and write out the definition.
		fmt.Fprint(saveBuf, "\treturn props, nil")
		fmeths = append(fmeths, &Method{
			Body:         saveBuf.String(),
			Name:         "Save",
			ReceiverID:   initial,
			ReceiverType: schema.kind,
			Signature:    "() ([]datastore.Property, error)",
		})
		saveBuf.Reset()
		// Append the footer for the NewX method and write out the definition.
		if autoset {
			fmt.Fprint(consBuf, "\n\t}")
		} else {
			fmt.Fprint(consBuf, "}")
		}
		fmeths = append(fmeths, &Method{
			Body:         consBuf.String(),
			Name:         "New" + schema.kind,
			ReceiverID:   "",
			ReceiverType: "",
			Signature:    fmt.Sprintf("() (*%s)", schema.kind),
		})
		consBuf.Reset()
		// Write out the remaining generated methods for the model package.
		tdata := TemplateData{Kind: schema.kind, KindLower: strings.ToLower(schema.kind)}
		fmeths = append(fmeths, &Method{
			Name:         "GetAll" + schema.kind,
			ReceiverID:   "q",
			ReceiverType: "Query",
			Signature:    fmt.Sprintf("() ([]*%s, []*Key, error)", schema.kind),
			Body: render("", `
	var (
		entities	[]*{{.Kind}}
		keys		[]*Key
	)
	if err := q.validate(); err != nil {
		return nil, nil, err
	}
	ctx, cancel := q.getContextCanceler()
	for t := config.DataClient.Run(ctx, q.query); ; {
		var ent {{.Kind}}
		key, err := t.Next(&ent)
		if err == datastore.Done {
			break
		}
		if err != nil {
			cancel()
			return nil, nil, err
		}
		entities = append(entities, &ent)
		keys = append(keys, &Key{Datastore: key})
	}
	cancel()
	return entities, keys, nil
`, tdata)})
		fmeths = append(fmeths, &Method{
			Name:         "Get" + schema.kind + "Page",
			ReceiverID:   "q",
			ReceiverType: "Query",
			Signature:    fmt.Sprintf("(limit int) ([]*%s, []*Key, datastore.Cursor, error)", schema.kind),
			Body: render("", `
	var (
		cursor		datastore.Cursor
		entities	[]*{{.Kind}}
		keys		[]*Key
		seen		int
	)
	ctx, cancel := q.getContextCanceler()
	for t := config.DataClient.Run(ctx, q.query.Limit(limit+1)); ; {
		var ent {{.Kind}}
		key, err := t.Next(&ent)
		if err == datastore.Done {
			break
		}
		if err != nil {
			cancel()
			return nil, nil, cursor, err
		}
		entities = append(entities, &ent)
		keys = append(keys, &Key{Datastore: key})
		seen += 1
		if seen == limit {
			cursor, err = t.Cursor()
			if err != nil {
				cancel()
				return nil, nil, cursor, err
			}
			break
		}
	}
	cancel()
	return entities, keys, cursor, nil
`, tdata)})
		// Write out the remaining generated methods for the web package.
		smeths = append(smeths, &Method{
			Name:         schema.kind + "ByKey",
			ReceiverID:   "c",
			ReceiverType: "Context",
			Signature:    fmt.Sprintf("(key *model.Key) (*model.%s, error)", schema.kind),
			Body: render("XByKey", `
	entity := &model.{{.Kind}}{}
	err := c.DataGet(key, entity)
	return entity, err
`, tdata)})
		smeths = append(smeths, &Method{
			Name:         schema.kind + "ByID",
			ReceiverID:   "c",
			ReceiverType: "Context",
			Signature:    fmt.Sprintf("(id int64, parent ...*model.Key) (*model.%s, error)", schema.kind),
			Body: render("XByID", `
	entity := &model.{{.Kind}}{}
	err := c.DataGet(c.KeyForID(model.{{.Kind}}Kind, id, parent...), entity)
	return entity, err
`, tdata)})
		smeths = append(smeths, &Method{
			Name:         schema.kind + "ByName",
			ReceiverID:   "c",
			ReceiverType: "Context",
			Signature:    fmt.Sprintf("(name string, parent ...*model.Key) (*model.%s, error)", schema.kind),
			Body: render("XByName", `
	entity := &model.{{.Kind}}{}
	err := c.DataGet(c.KeyForName(model.{{.Kind}}Kind, name, parent...), entity)
	return entity, err
`, tdata)})
		smeths = append(smeths, &Method{
			Name:         "KeyFor" + schema.kind + "ID",
			ReceiverID:   "c",
			ReceiverType: "Context",
			Signature:    "(id int64, parent ...*model.Key) *model.Key",
			Body: render("KeyForXID", `
	return c.KeyForID(model.{{.Kind}}Kind, id, parent...)
`, tdata)})
		smeths = append(smeths, &Method{
			Name:         "KeyFor" + schema.kind + "Name",
			ReceiverID:   "c",
			ReceiverType: "Context",
			Signature:    "(name string, parent ...*model.Key) *model.Key",
			Body: render("KeyForXName", `
	return c.KeyForName(model.{{.Kind}}Kind, name, parent...)
`, tdata)})
		smeths = append(smeths, &Method{
			Name:         "NewKeyFor" + schema.kind,
			ReceiverID:   "c",
			ReceiverType: "Context",
			Signature:    "(parent ...*model.Key) *model.Key",
			Body: render("NewKeyForX", `
	return c.NewKey(model.{{.Kind}}Kind, parent...)
`, tdata)})
		smeths = append(smeths, &Method{
			Name:         "Query" + schema.kind,
			ReceiverID:   "c",
			ReceiverType: "Context",
			Signature:    "() *model.Query",
			Body: render("QueryX", `
	return c.Query(model.{{.Kind}}Kind)
`, tdata)})
		smeths = append(smeths, &Method{
			Name:         "SaveNew" + schema.kind,
			ReceiverID:   "c",
			ReceiverType: "Context",
			Signature:    fmt.Sprintf("(%s *model.%s, parent ...*model.Key) (*model.Key, error)", strings.ToLower(schema.kind), schema.kind),
			Body: render("SaveNewX", `
	_key := c.NewKey(model.{{.Kind}}Kind, parent...)
	_err := c.DataPut(_key, {{.KindLower}})
	if _err != nil {
		return nil, _err
	}
	return _key, nil
`, tdata)})
	}

	fmeths.Write(fbuf)
	smeths.Write(sbuf)

	// Write the files to disk.
	err := ioutil.WriteFile(os.Args[1], fbuf.Bytes(), 0644)
	if err != nil {
		exit("%s", err)
	}

	err = ioutil.WriteFile(os.Args[2], sbuf.Bytes(), 0644)
	if err != nil {
		exit("%s", err)
	}

}
