// Public Domain (-) 2016 The GitFund Authors.
// See the GitFund UNLICENSE file for details.

package main

import (
	"bytes"
	"fmt"
	"os"
	"reflect"
	"sort"
	"strings"
	"unicode"
	"unicode/utf8"

	"github.com/tav/gitfund/app/model"
)

func exit(format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, "ERROR: "+format+"\n", args...)
	os.Exit(1)
}

func main() {

	// Sort the entity kinds into alphabetical order.
	keys := []string{}
	for key, _ := range model.KindRegistry {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	// Create the buffer to write to and spit out the header.
	buf := &bytes.Buffer{}
	buf.WriteString("// AUTOGENERATED. DO NOT EDIT.\npackage model\n\nconst (\n")

	// Loop over each entity kind, validate, and write the relevant metadata.
	for _, key := range keys {
		rt := reflect.TypeOf(model.KindRegistry[key])
		kind := rt.Name()
		fmt.Fprintf(buf, "\t%sKind = %q\n", kind, key)
		n := rt.NumField()
		seen := map[string]string{}
		for i := 0; i < n; i++ {
			field := rt.Field(i)
			// Skip unexported fields.
			r, _ := utf8.DecodeRuneInString(field.Name)
			if !unicode.IsUpper(r) {
				continue
			}
			// Ensure the field has a datastore struct tag.
			tag := field.Tag.Get("datastore")
			if tag == "" {
				exit("missing datastore struct tag for %s.%s", kind, field.Name)
			}
			// Ensure the field name hasn't been used already.
			split := strings.Split(tag, ",")
			name := ""
			noindex := false
			switch len(split) {
			case 2:
				name = split[0]
				if split[1] == "noindex" {
					noindex = true
				} else {
					exit("invalid struct tag for %s.%s: %q", kind, field.Name, tag)
				}
			case 1:
				name = split[0]
			default:
				exit("invalid struct tag for %s.%s: %q", kind, field.Name, tag)
			}
			name = strings.TrimSpace(name)
			if name == "" {
				exit("empty field name for %s.%s: %q", kind, field.Name, tag)
			}
			if prev, exists := seen[name]; exists {
				exit("field name %q for %s.%s already used for %s.%s", name, kind, field.Name, kind, prev)
			}
			seen[name] = field.Name
			// If not indexed, skip writing out the field name.
			if noindex {
				continue
			}
			fmt.Fprintf(buf, "\t%s_%s = \"%s =\"\n", kind, field.Name, name)
			fmt.Fprintf(buf, "\t%s_%s_asc = \"%s\"\n", kind, field.Name, name)
			fmt.Fprintf(buf, "\t%s_%s_desc = \"-%s\"\n", kind, field.Name, name)
			fmt.Fprintf(buf, "\t%s_%s_gt = \"%s >\"\n", kind, field.Name, name)
			fmt.Fprintf(buf, "\t%s_%s_gte = \"%s >=\"\n", kind, field.Name, name)
			fmt.Fprintf(buf, "\t%s_%s_lt = \"%s <\"\n", kind, field.Name, name)
			fmt.Fprintf(buf, "\t%s_%s_lte = \"%s <=\"\n", kind, field.Name, name)
		}
	}

	// Close the const block and dump the buffer to stdout.
	buf.WriteString(")\n")
	fmt.Print(buf.String())

}
