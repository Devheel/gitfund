// Public Domain (-) 2016 The GitFund Authors.
// See the GitFund UNLICENSE file for details.

package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"reflect"
	"sort"
	"strings"
	"time"
	"unicode"
	"unicode/utf8"

	"github.com/tav/gitfund/app/model"
)

var (
	typeOfByteSlice = reflect.TypeOf([]byte(nil))
	typeOfTime      = reflect.TypeOf(time.Time{})
)

type Prop struct {
	auto     string
	field    string
	multiple bool
	name     string
	noindex  bool
	typ      string
}

type Schema struct {
	dbfields map[string]*Prop
	fields   map[string]*Prop
	kind     string
	props    []*Prop
	slices   []string
}

func exit(format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, "ERROR: "+format+"\n", args...)
	os.Exit(1)
}

func main() {

	if len(os.Args) != 3 {
		fmt.Println("Usage: genmodel FIELDS_OUTPUT_PATH CONTEXT_MODEL_OUTPUT_PATH")
		os.Exit(1)
	}

	// Sort the entity kinds into alphabetical order.
	keys := []string{}
	for key, _ := range model.KindRegistry {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	// Define a map to hold the schema definitions.
	schemas := map[string]*Schema{}

	// Create the buffers to write to.
	fbuf := &bytes.Buffer{}
	sbuf := &bytes.Buffer{}

	// Spit out the fields header with the opening for the const block.
	fbuf.WriteString(`// AUTOGENERATED. DO NOT EDIT.

package model

import (
	"fmt"
	"time"

	"google.golang.org/cloud/datastore"
)

const (
`)

	// Spit out the schema header with a dummy variable using the time package
	// in case time.Time isn't used anywhere.
	sbuf.WriteString(`// AUTOGENERATED. DO NOT EDIT.

package web

import (
	"time"

	"github.com/tav/gitfund/app/model"
	"google.golang.org/cloud/datastore"
)

var _ = time.Time{}
`)

	// Loop over each entity kind, validate, and write the relevant metadata.
	for _, key := range keys {
		rt := reflect.TypeOf(model.KindRegistry[key])
		kind := rt.Name()
		fmt.Fprintf(fbuf, "\t%sKind = %q\n", kind, key)
		n := rt.NumField()
		seen := map[string]string{}
		dbfields := map[string]*Prop{}
		fields := map[string]*Prop{}
		props := []*Prop{}
		slices := []string{}
		for i := 0; i < n; i++ {
			field := rt.Field(i)
			// Skip unexported fields.
			r, _ := utf8.DecodeRuneInString(field.Name)
			if !unicode.IsUpper(r) {
				continue
			}
			// Ensure the field has a datastore struct tag.
			tag := field.Tag.Get("model")
			if tag == "" {
				exit("missing model struct tag for %s.%s", kind, field.Name)
			}
			// Ensure the field name hasn't been used already.
			split := strings.Split(tag, ",")
			name := ""
			noindex := false
			auto := ""
			switch len(split) {
			case 3:
				name = split[0]
				if split[1] == "noindex" {
					noindex = true
					auto = split[2]
				} else if split[2] == "noindex" {
					noindex = true
					auto = split[1]
				} else {
					exit("invalid struct tag for %s.%s: %q", kind, field.Name, tag)
				}
			case 2:
				name = split[0]
				if split[1] == "noindex" {
					noindex = true
				} else {
					auto = split[1]
				}
			case 1:
				name = split[0]
			default:
				exit("invalid struct tag for %s.%s: %q", kind, field.Name, tag)
			}
			name = strings.TrimSpace(name)
			if name == "" {
				exit("empty datastore field name for %s.%s: %q", kind, field.Name, tag)
			}
			if prev, exists := seen[name]; exists {
				exit("datastore field name %q for %s.%s already used for %s.%s", name, kind, field.Name, kind, prev)
			}
			seen[name] = field.Name
			// Define the property.
			ft := field.Type
			multiple := false
			typ := ""
			switch ft {
			case typeOfByteSlice:
				typ = "[]byte"
			case typeOfTime:
				typ = "time.Time"
			default:
				switch ft.Kind() {
				case reflect.Bool:
					typ = "bool"
				case reflect.Float64:
					typ = "float64"
				case reflect.Int64:
					typ = "int64"
				case reflect.Slice:
					multiple = true
					st := ft.Elem()
					switch ft.Elem() {
					case typeOfByteSlice:
						typ = "[]byte"
					default:
						slices = append(slices, field.Name)
						switch st.Kind() {
						case reflect.String:
							typ = "string"
						default:
							exit("unsuported slice type %s specified for %s.%s", ft, kind, field.Name)
						}
					}
				case reflect.String:
					typ = "string"
				default:
					exit("unsupported type %s specified %s.%s", ft, kind, field.Name)
				}
			}
			if multiple && auto != "" {
				exit("default value %q set for %s field %s.%s", auto, ft, kind, field.Name)
			}
			prop := &Prop{
				auto:     auto,
				field:    field.Name,
				multiple: multiple,
				name:     name,
				noindex:  noindex,
				typ:      typ,
			}
			props = append(props, prop)
			dbfields[name] = prop
			fields[field.Name] = prop
			// If not indexed, skip writing out the field name.
			if noindex {
				continue
			}
			fmt.Fprintf(fbuf, "\t%s_%s = \"%s\"\n", kind, field.Name, name)
			fmt.Fprintf(fbuf, "\t%s_%s_desc = \"-%s\"\n", kind, field.Name, name)
			fmt.Fprintf(fbuf, "\t%s_%s_eq = \"%s =\"\n", kind, field.Name, name)
			fmt.Fprintf(fbuf, "\t%s_%s_gt = \"%s >\"\n", kind, field.Name, name)
			fmt.Fprintf(fbuf, "\t%s_%s_gte = \"%s >=\"\n", kind, field.Name, name)
			fmt.Fprintf(fbuf, "\t%s_%s_lt = \"%s <\"\n", kind, field.Name, name)
			fmt.Fprintf(fbuf, "\t%s_%s_lte = \"%s <=\"\n", kind, field.Name, name)
		}
		schemas[key] = &Schema{
			dbfields: dbfields,
			fields:   fields,
			kind:     kind,
			props:    props,
			slices:   slices,
		}
	}

	// Close the const block and write a dummy variable using the time package
	// in case time.Time isn't used anywhere.
	fbuf.WriteString(`)

var _ = time.Time{}
`)

	// Loop through the schema definitions and write out Load/Save methods and
	// utility methods on web.Context.
	for _, key := range keys {
		schema := schemas[key]
		initial := strings.ToLower(string(schema.kind[0]))
		// Write the first set of utility methods for web.Context.
		fmt.Fprintf(sbuf, `
func (c *Context) %sByKey(key *datastore.Key) (*model.%s, error) {
	entity := &model.%s{}
	err := c.Get(key, entity)
	return entity, err
}

func (c *Context) %sByID(id int64, parent ...*datastore.Key) (*model.%s, error) {
	entity := &model.%s{}
	err := c.Get(c.KeyID(model.%sKind, id, parent...), entity)
	return entity, err
}

func (c *Context) %sByName(name string, parent ...*datastore.Key) (*model.%s, error) {
	entity := &model.%s{}
	err := c.Get(c.KeyName(model.%sKind, name, parent...), entity)
	return entity, err
}

func (c *Context) KeyFor%sID(id int64, parent ...*datastore.Key) *datastore.Key {
	return c.KeyID(model.%sKind, id, parent...)
}

func (c *Context) KeyFor%sName(name string, parent ...*datastore.Key) *datastore.Key {
	return c.KeyName(model.%sKind, name, parent...)
}

func (c *Context) NewKeyFor%s(parent ...*datastore.Key) *datastore.Key {
	return c.NewKey(model.%sKind, parent...)
}

func (c *Context) Query%s() *Query {
	return c.Query(model.%sKind)
}

func (q *Query) GetAll%s() ([]*model.%s, []*datastore.Key, error) {
	var (
		entities	[]*model.%s
		keys		[]*datastore.Key
	)
	q.ensureLimitSet()
	for t := dataClient.Run(q.ctx, q.query); ; {
		var ent model.%s
		key, err := t.Next(&ent)
		if err == datastore.Done {
			break
		}
		if err != nil {
			return nil, nil, err
		}
		entities = append(entities, &ent)
		keys = append(keys, key)
	}
	return entities, keys, nil
}

func (q *Query) Get%sPage(limit int) ([]*model.%s, []*datastore.Key, datastore.Cursor, error) {
	var (
		cursor		datastore.Cursor
		entities	[]*model.%s
		keys		[]*datastore.Key
		seen		int
	)
	for t := dataClient.Run(q.ctx, q.query.Limit(limit+1)); ; {
		var ent model.%s
		key, err := t.Next(&ent)
		if err == datastore.Done {
			break
		}
		if err != nil {
			return nil, nil, cursor, err
		}
		entities = append(entities, &ent)
		keys = append(keys, key)
		seen += 1
		if seen == limit {
			cursor, err = t.Cursor()
			if err != nil {
				return nil, nil, cursor, err
			}
			break
		}
	}
	return entities, keys, cursor, nil
}

func (c *Context) New%s() *model.%s {
	return &model.%s{
`, schema.kind, schema.kind, schema.kind, schema.kind, schema.kind, schema.kind,
			schema.kind, schema.kind, schema.kind, schema.kind, schema.kind,
			schema.kind, schema.kind, schema.kind, schema.kind, schema.kind,
			schema.kind, schema.kind, schema.kind, schema.kind, schema.kind,
			schema.kind, schema.kind, schema.kind, schema.kind, schema.kind,
			schema.kind, schema.kind, schema.kind, schema.kind)
		// Sort the model fields into alphabetical order.
		fields := []string{}
		for field, _ := range schema.fields {
			fields = append(fields, field)
		}
		sort.Strings(fields)
		// Write the header for the Load method.
		fmt.Fprintf(fbuf, `

func (%s *%s) Load(props []datastore.Property) error {
	ok := true
`, initial, schema.kind)
		sort.Strings(schema.slices)
		for _, field := range schema.slices {
			prop := schema.fields[field]
			fmt.Fprintf(fbuf, "\t%s.%s = []%s{}\n", initial, field, prop.typ)
		}
		fmt.Fprint(fbuf, "\tfor _, prop := range props {\n\t\tswitch prop.Name {\n")
		// Sort the datastore field names into alphabetical order.
		dbfields := []string{}
		for dbfield, _ := range schema.dbfields {
			dbfields = append(dbfields, dbfield)
		}
		sort.Strings(dbfields)
		// Loop through the fields and write out code to load the property.
		for _, dbfield := range dbfields {
			prop := schema.dbfields[dbfield]
			fmt.Fprintf(fbuf, "\t\tcase %q:\n", dbfield)
			if prop.multiple {
				fmt.Fprintf(fbuf, "\t\t\tval, ok := prop.Value.(%s)\n", prop.typ)
				fmt.Fprintf(fbuf, `			if !ok {
				return fmt.Errorf("model: property for %s.%s element is not %s")
			}
`, schema.kind, prop.field, prop.typ)
				fmt.Fprintf(
					fbuf, "\t\t\t%s.%s = append(%s.%s, val)\n",
					initial, prop.field, initial, prop.field)
			} else {
				fmt.Fprintf(fbuf, "\t\t\t%s.%s, ok = prop.Value.(%s)\n", initial, prop.field, prop.typ)
				fmt.Fprintf(fbuf, `			if !ok {
				return fmt.Errorf("model: property for %s.%s is not %s")
			}
`, schema.kind, prop.field, prop.typ)
			}
		}
		// Write the footer for the Load method.
		fmt.Fprint(fbuf, "\t\t}\n\t}\n\treturn nil\n}")
		// Write the header for the Save method.
		fmt.Fprintf(fbuf, `

func (%s *%s) Save() ([]datastore.Property, error) {
	props := []datastore.Property{}
`, initial, schema.kind)
		// Loop through the fields and write out code to save the property and
		// define the utility constructor on web.Context.
		for _, field := range fields {
			prop := schema.fields[field]
			if prop.multiple {
				fmt.Fprintf(sbuf, "\t\t%s: []%s{},\n", field, prop.typ)
				fmt.Fprintf(fbuf, "\tfor _, elem := range %s.%s {\n", initial, field)
				fmt.Fprint(fbuf, "\t\tprops = append(props, datastore.Property{\n")
				fmt.Fprintf(fbuf, "\t\t\tName: %q,\n", prop.name)
				if prop.noindex {
					fmt.Fprint(fbuf, "\t\t\tNoIndex: true,\n")
				}
				fmt.Fprint(fbuf, "\t\t\tValue: elem,\n")
				fmt.Fprint(fbuf, "\t\t})\n")
				fmt.Fprint(fbuf, "\t}\n")
			} else {
				fmt.Fprint(fbuf, "\tprops = append(props, datastore.Property{\n")
				fmt.Fprintf(fbuf, "\t\tName: %q,\n", prop.name)
				if prop.noindex {
					fmt.Fprint(fbuf, "\t\tNoIndex: true,\n")
				}
				fmt.Fprintf(fbuf, "\t\tValue: %s.%s,\n", initial, field)
				fmt.Fprint(fbuf, "\t})\n")
			}
			if prop.auto != "" {
				switch prop.typ {
				case "string":
					fmt.Fprintf(sbuf, "\t\t%s: %q,\n", field, prop.auto)
				case "int64", "float64", "bool":
					fmt.Fprintf(sbuf, "\t\t%s: %s,\n", field, prop.auto)
				case "[]byte":
					fmt.Fprintf(sbuf, "\t\t%s: []byte(%q),\n", field, prop.auto)
				case "time.Time":
					if prop.auto == "now" {
						fmt.Fprintf(sbuf, "\t\t%s: time.Now().UTC(),\n", field)
					} else {
						exit("unsupported default value %q for time.Time field %s.%s",
							prop.auto, schema.kind, field)
					}
				}
			}
		}
		// Write the footer for the Save and constructor methods.
		fmt.Fprint(fbuf, "\treturn props, nil\n}\n")
		fmt.Fprint(sbuf, "\t}\n}\n")
	}

	// Write the files to disk.
	err := ioutil.WriteFile(os.Args[1], fbuf.Bytes(), 0644)
	if err != nil {
		fmt.Printf("ERROR: %s", err)
		os.Exit(1)
	}

	err = ioutil.WriteFile(os.Args[2], sbuf.Bytes(), 0644)
	if err != nil {
		fmt.Printf("ERROR: %s", err)
		os.Exit(1)
	}

}
